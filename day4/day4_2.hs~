import qualified Data.Set as Set
import Data.Bifunctor(bimap)
import Data.List(transpose)

setify :: [[Int]] -> ([Set.Set Int], [Set.Set Int])
setify matrix = (map Set.fromList matrix, map Set.fromList (transpose matrix))

chunkList :: Int -> [a] -> [[a]]
chunkList _ [] = []
chunkList n lis = if length lis < n then [lis] else pfx : chunkList n sfx
  where (pfx, sfx) = splitAt n lis

wordsWhen :: (Char -> Bool) -> String -> [String]
wordsWhen p s =  case dropWhile p s of
                      "" -> []
                      s' -> w : wordsWhen p s''
                            where (w, s'') = break p s'

finalMatrix :: [Int] -> [([Set.Set Int], [Set.Set Int])] -> (Int, Int)
finalMatrix [] _ = error "bottom reached"
finalMatrix (n:ns) matList = case length reduced of
  0 -> bingos [n] (last matList)
  1 -> bingos (n:ns) reduced
  _ -> finalMatrix ns matList
  where reduced = markn n matList

markn :: Int -> [[([Set.Set Int], [Set.Set Int])] ] -> [([Set.Set Int], [Set.Set Int])]
markn _ [] = []
markn n matList = filter (\(rows, cols) -> notElem Set.empty rows && notElem Set.empty cols) . map (bimap (map (Set.delete n)) (map (Set.delete n))) $ matList

bingos :: [Int] -> ([Set.Set Int], [Set.Set Int]) -> (Int, Int)
